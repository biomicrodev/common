import xml.etree.ElementTree as ET
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Any, Set, Optional, Tuple

import dask.array as da
import numpy as np
import zarr
from tifffile.tifffile import ZarrTiffStore, TiffFile, TiffPageSeries, TiffPage
from zarr import Group

from .utils import str2int

NS_SCN = "{http://www.leica-microsystems.com/scn/2010/10/01}"


class PointF:
    """
    I'd use a dataclass here but I'm too lazy to figure out how to validate its setters
    """

    def __init__(self, *, x: float, y: float):
        # make kwargs explicit
        self.x = x
        self.y = y

    @property
    def x(self) -> float:
        return self._x

    @x.setter
    def x(self, val: float) -> None:
        self._x = float(val)

    @property
    def y(self) -> float:
        return self._y

    @y.setter
    def y(self, val: float) -> None:
        self._y = float(val)

    def __repr__(self) -> str:
        return f"PointF(x={self.x}, y={self.y})"

    def as_tuple(self) -> Tuple[float, float]:
        return self.x, self.y


@dataclass(frozen=True)
class Pyramid:
    """
    A Pyramid is a set of arrays that form a geometric sequence in image space.
    The microns per pixel value is for the base array.
    The offset is in physical units (to match napari's API).
    """

    layers: List[da.Array]
    mpp: PointF
    offset: PointF


@dataclass(frozen=True)
class PyramidGroup:
    dtype: np.dtype
    channel_index: int
    n_channels: int
    axes: str
    file_format: str
    flags: Set[str]

    label: Optional[np.ndarray]
    pyramids: List[Pyramid]
    background: Optional[Pyramid] = None


def parse_svs_metadata(s: str) -> Dict[str, Any]:
    """
    The metadata contained in SVS files generated by Leica brightfield microscopes is
    the name of the library used to generate the file, followed by a newline, followed
    by a pipe-separated list of values. The first element in the list contains general
    info about the image, and the remaining values are key-value pairs separated by
    equals signs.
    """
    library, info = s.split("\n")
    library = library.strip()
    info = info.split("|")

    general = info[0]
    pairs = [p.split("=") for p in info[1:]]
    properties = {k.strip(): v.strip() for k, v in pairs}

    # try and parse numerical values (at least for now)
    for key, value in properties.items():
        try:
            value = int(value)
        except ValueError:
            try:
                value = float(value)
            except ValueError:
                pass
            else:
                properties[key] = value
        else:
            properties[key] = value

    return {"library": library, "general": general, **properties}


def create_store(path: Path, name: str, level: int) -> ZarrTiffStore:
    with TiffFile(str(path)) as file:
        series: List[TiffPageSeries] = file.series
        series: TiffPageSeries = next(s for s in series if s.name == name)
        return series.aszarr(level)


def get_svs_layers(path: Path, series: TiffPageSeries) -> List[da.Array]:
    store: ZarrTiffStore = series.aszarr()
    group: Group = zarr.open(store, mode="r")
    levels: List[Dict[str, str]] = group.attrs["multiscales"][0]["datasets"]

    pyramid: List[da.Array] = []
    for level in levels:
        # create individual stores for each level
        _store: ZarrTiffStore = create_store(path, series.name, int(level["path"]))
        array: da.Array = da.from_zarr(_store, chunks=("auto", "auto", "auto"))
        pyramid.append(array)

    # pyramid: List[da.Array] = [
    #     da.from_zarr(store, component=level["path"], chunks=("auto", "auto", 1))
    #     for level in levels
    # ]

    return pyramid


def get_scn_pyramids(
    path: Path, metadata: ET.Element, series: List[TiffPageSeries]
) -> List[Pyramid]:
    """
    SCN files contain metadata in OME-XML format.
    """

    pyramids: List[Pyramid] = []
    names: List[str] = [s.name for s in series]
    for name in names:
        image_node: ET.Element = metadata.find(f'.//{NS_SCN}image[@name="{name}"]')
        view_node: ET.Element = image_node.find(f".//{NS_SCN}view")

        physical_size = PointF(
            x=str2int(view_node.get("sizeX")) / 1000,
            y=str2int(view_node.get("sizeY")) / 1000,
        )

        physical_offset = PointF(
            x=str2int(view_node.get("offsetX")) / 1000,
            y=str2int(view_node.get("offsetY")) / 1000,
        )

        pixels_node: ET.Element = image_node.find(f".//{NS_SCN}pixels")
        pixel_size = PointF(
            x=str2int(pixels_node.get("sizeX")), y=str2int(pixels_node.get("sizeY"))
        )

        # could override `__div__` in `Point` class... this only appears once though
        mpp = PointF(x=physical_size.x / pixel_size.x, y=physical_size.y / pixel_size.y)

        store: ZarrTiffStore = next(s for s in series if s.name == name).aszarr()
        group: Group = zarr.open(store, mode="r")
        levels: List[Dict[str, str]] = group.attrs["multiscales"][0]["datasets"]

        pyramid: List[da.Array] = []
        for level in levels:
            # create individual stores for each level to get around lock
            _store = create_store(path, name, int(level["path"]))
            array = da.from_zarr(_store, chunks=("auto", "auto", "auto"))
            pyramid.append(array)

        # pyramid: List[da.Array] = [
        #     da.from_zarr(store, component=level["path"], chunks=(1, "auto", "auto"))
        #     for level in levels
        # ]

        pyramids.append(Pyramid(layers=pyramid, mpp=mpp, offset=physical_offset))

    return pyramids


def read_image(path: Path) -> Optional[PyramidGroup]:
    with TiffFile(str(path)) as file:
        flags: Set[str] = file.flags
        series: List[TiffPageSeries] = file.series
        pages: List[TiffPage] = file.pages

        scn_metadata = file.scn_metadata

    if "svs" in flags:
        # get metadata
        metadata: Dict[str, Any] = parse_svs_metadata(pages[0].description)

        # get label
        label: np.ndarray = next(s for s in series if s.name == "Label").asarray()

        # get pyramids
        image: TiffPageSeries = next(s for s in series if s.name == "Baseline")
        pyramids = [
            Pyramid(
                layers=get_svs_layers(path, image),
                mpp=PointF(x=metadata["MPP"], y=metadata["MPP"]),
                offset=PointF(x=0, y=0),
            )
        ]

        axes: str = image.axes
        channel_index: int = list(axes).index("S")

        return PyramidGroup(
            dtype=image.dtype,
            channel_index=channel_index,
            n_channels=image.shape[channel_index],
            axes=axes,
            file_format="svs",
            flags=flags,
            label=label,
            pyramids=pyramids,
        )

    elif "scn" in flags:
        # get metadata
        metadata: ET.Element = ET.fromstring(scn_metadata)

        # get label
        label_ifd = int(
            metadata.find(f".//{NS_SCN}supplementalImage[@type='label']").get("ifd")
        )
        label = next(p for p in pages if p.index == label_ifd).asarray()

        sources = {
            metadata.find(
                f'.//{NS_SCN}image[@name="{s.name}"]' f"//{NS_SCN}illuminationSource"
            ).text
            for s in series
        }

        if "fluorescence" in sources:
            # fluorescence image
            series = [s for s in series if s.axes == "CYX"]
            axes = series[0].axes
            channel_index = list(axes).index("C")
            n_channels = series[0].shape[channel_index]
            pyramids = get_scn_pyramids(path, metadata, series)

            return PyramidGroup(
                dtype=series[0].dtype,
                channel_index=channel_index,
                n_channels=n_channels,
                axes=axes,
                file_format="scn",
                flags=flags,
                label=label,
                pyramids=pyramids,
            )

        else:
            # brightfield image (until we start using other modalities)
            axes = series[0].axes
            channel_index = list(axes).index("S")
            n_channels = series[0].shape[channel_index]
            pyramids = get_scn_pyramids(path, metadata, series)

            return PyramidGroup(
                dtype=series[0].dtype,
                channel_index=channel_index,
                n_channels=n_channels,
                axes=axes,
                file_format="scn",
                flags=flags,
                label=label,
                pyramids=pyramids[1:],  # first pyramid is background pyramid
                background=pyramids[0],  # background pyramid
            )
